<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lasso.util &mdash; lasso  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" />
    <link rel="next" title="lasso.logger" href="../lasso.logger/" />
    <link rel="prev" title="lasso.Parameters" href="../lasso.Parameters/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../" class="icon icon-home"> lasso
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../starting/">Starting Out</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../setup/">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../running/">Running Lasso</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../autodoc/">Lasso Classes and Functions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../autodoc/#base-classes">Base Classes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../autodoc/#utils-and-functions">Utils and Functions</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">lasso.util</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.Point"><code class="docutils literal notranslate"><span class="pre">Point</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.Polygon"><code class="docutils literal notranslate"><span class="pre">Polygon</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.partial"><code class="docutils literal notranslate"><span class="pre">partial</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.column_name_to_parts"><code class="docutils literal notranslate"><span class="pre">column_name_to_parts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.create_locationreference"><code class="docutils literal notranslate"><span class="pre">create_locationreference()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.geodesic_point_buffer"><code class="docutils literal notranslate"><span class="pre">geodesic_point_buffer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.get_shared_streets_intersection_hash"><code class="docutils literal notranslate"><span class="pre">get_shared_streets_intersection_hash()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.hhmmss_to_datetime"><code class="docutils literal notranslate"><span class="pre">hhmmss_to_datetime()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.secs_to_datetime"><code class="docutils literal notranslate"><span class="pre">secs_to_datetime()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.shorten_name"><code class="docutils literal notranslate"><span class="pre">shorten_name()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.transform"><code class="docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lasso.util.unidecode"><code class="docutils literal notranslate"><span class="pre">unidecode()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lasso.logger/">lasso.logger</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../">lasso</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../autodoc/">Lasso Classes and Functions</a></li>
      <li class="breadcrumb-item active">lasso.util</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/_generated/lasso.util.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-lasso.util">
<span id="lasso-util"></span><h1>lasso.util<a class="headerlink" href="#module-lasso.util" title="Permalink to this heading"></a></h1>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lasso.util.column_name_to_parts" title="lasso.util.column_name_to_parts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">column_name_to_parts</span></code></a>(c[, parameters])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lasso.util.create_locationreference" title="lasso.util.create_locationreference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_locationreference</span></code></a>(node, link)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lasso.util.geodesic_point_buffer" title="lasso.util.geodesic_point_buffer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_point_buffer</span></code></a>(lat, lon, meters)</p></td>
<td><p>creates circular buffer polygon for node</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lasso.util.get_shared_streets_intersection_hash" title="lasso.util.get_shared_streets_intersection_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_shared_streets_intersection_hash</span></code></a>(lat, long)</p></td>
<td><p>Calculated per:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lasso.util.hhmmss_to_datetime" title="lasso.util.hhmmss_to_datetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hhmmss_to_datetime</span></code></a>(hhmmss_str)</p></td>
<td><p>Creates a datetime time object from a string of hh:mm:ss</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lasso.util.secs_to_datetime" title="lasso.util.secs_to_datetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">secs_to_datetime</span></code></a>(secs)</p></td>
<td><p>Creates a datetime time object from a seconds from midnight</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lasso.util.shorten_name" title="lasso.util.shorten_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shorten_name</span></code></a>(name)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="lasso.util.Point">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">Point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/point/#Point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Point" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseGeometry</span></code></p>
<p>A zero dimensional feature</p>
<p>A point has zero length and zero area.</p>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></span></dt>
<dd><p>Coordinate values</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">POINT (1 -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">y</span>
<span class="go">-1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span>
<span class="go">1.0</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.almost_equals">
<span class="sig-name descname"><span class="pre">almost_equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.almost_equals" title="Permalink to this definition"></a></dt>
<dd><p>True if geometries are equal at all coordinates to a
specified decimal place.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.8.0: </span>The ‘almost_equals()’ method is deprecated
and will be removed in Shapely 2.0 because the name is
confusing. The ‘equals_exact()’ method should be used
instead.</p>
</div>
<p>Refers to approximate coordinate equality, which requires
coordinates to be approximately equal and in the same order for
all components of a geometry.</p>
<p>Because of this it is possible for “equals()” to be True for two
geometries and “almost_equals()” to be False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]),</span>
<span class="gp">... </span>    <span class="mf">1e-6</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.array_interface">
<span class="sig-name descname"><span class="pre">array_interface</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/point/#Point.array_interface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Point.array_interface" title="Permalink to this definition"></a></dt>
<dd><p>Provide the Numpy array protocol.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.buffer">
<span class="sig-name descname"><span class="pre">buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadsegs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cap_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">join_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mitre_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single_sided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.buffer" title="Permalink to this definition"></a></dt>
<dd><p>Get a geometry that represents all points within a distance
of this geometry.</p>
<p>A positive distance produces a dilation, a negative distance an
erosion. A very small or zero distance may sometimes be used to
“tidy” a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> (<em>float</em>) – The distance to buffer around the object.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The resolution of the buffer around each vertex of the
object.</p></li>
<li><p><strong>quadsegs</strong> (<em>int</em><em>, </em><em>optional</em>) – Sets the number of line segments used to approximate an
angle fillet.  Note: the use of a <cite>quadsegs</cite> parameter is
deprecated and will be gone from the next major release.</p></li>
<li><p><strong>cap_style</strong> (<em>int</em><em>, </em><em>optional</em>) – The styles of caps are: CAP_STYLE.round (1), CAP_STYLE.flat
(2), and CAP_STYLE.square (3).</p></li>
<li><p><strong>join_style</strong> (<em>int</em><em>, </em><em>optional</em>) – The styles of joins between offset segments are:
JOIN_STYLE.round (1), JOIN_STYLE.mitre (2), and
JOIN_STYLE.bevel (3).</p></li>
<li><p><strong>mitre_limit</strong> (<em>float</em><em>, </em><em>optional</em>) – The mitre limit ratio is used for very sharp corners. The
mitre ratio is the ratio of the distance from the corner to
the end of the mitred offset corner. When two line segments
meet at a sharp angle, a miter join will extend the original
geometry. To prevent unreasonable geometry, the mitre limit
allows controlling the maximum length of the join corner.
Corners with a ratio which exceed the limit will be beveled.</p></li>
<li><p><strong>single_side</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>The side used is determined by the sign of the buffer
distance:</p>
<blockquote>
<div><p>a positive distance indicates the left-hand side
a negative distance indicates the right-hand side</p>
</div></blockquote>
<p>The single-sided buffer of point geometries is the same as
the regular buffer.  The End Cap Style for single-sided
buffers is always ignored, and forced to the equivalent of
CAP_FLAT.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Geometry</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The return value is a strictly two-dimensional geometry. All
Z coordinates of the original geometry will be ignored.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.wkt</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="s1">&#39;POINT (0.0 0.0)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>        <span class="c1"># 16-gon approx of a unit radius circle</span>
<span class="go">3.1365484905459...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>   <span class="c1"># 128-gon approximation</span>
<span class="go">3.141513801144...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># triangle approximation</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="n">CAP_STYLE</span><span class="o">.</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
<span class="go">[(1.0, 1.0), (1.0, -1.0), (-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="n">CAP_STYLE</span><span class="o">.</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.contains" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry contains the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.covered_by">
<span class="sig-name descname"><span class="pre">covered_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.covered_by" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry is covered by the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.covers">
<span class="sig-name descname"><span class="pre">covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.covers" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry covers the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.crosses">
<span class="sig-name descname"><span class="pre">crosses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.crosses" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometries cross, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.difference">
<span class="sig-name descname"><span class="pre">difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.difference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the difference of the geometries</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.disjoint">
<span class="sig-name descname"><span class="pre">disjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.disjoint" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries are disjoint, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.distance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless distance to other geometry (float)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">93892948296208</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.empty" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.equals">
<span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.equals" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries are equal, else False.</p>
<p>This method considers point-set equality (or topological
equality), and is equivalent to (self.within(other) &amp;
self.contains(other)).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.equals_exact">
<span class="sig-name descname"><span class="pre">equals_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.equals_exact" title="Permalink to this definition"></a></dt>
<dd><p>True if geometries are equal to within a specified
tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>BaseGeometry</em>) – The other geometry object in this comparison.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Absolute tolerance in the same units as coordinates.</p></li>
<li><p><strong>equality</strong> (<em>This method considers coordinate</em>) – </p></li>
<li><p><strong>requires</strong> (<em>which</em>) – </p></li>
<li><p><strong>components</strong> (<em>coordinates to be equal and in the same order for all</em>) – </p></li>
<li><p><strong>geometry.</strong> (<em>of a</em>) – </p></li>
<li><p><strong>two</strong> (<em>Because</em><em> of </em><em>this it is possible for &quot;equals</em><em>(</em><em>)</em><em>&quot; to be True for</em>) – </p></li>
<li><p><strong>False.</strong> (<em>geometries and &quot;equals_exact</em><em>(</em><em>)</em><em>&quot; to be</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]),</span>
<span class="gp">... </span>    <span class="mf">1e-6</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.geometryType">
<span class="sig-name descname"><span class="pre">geometryType</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.geometryType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.hausdorff_distance">
<span class="sig-name descname"><span class="pre">hausdorff_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.hausdorff_distance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless hausdorff distance to other geometry (float)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.interpolate" title="Permalink to this definition"></a></dt>
<dd><p>Return a point at the specified distance along a linear geometry</p>
<p>Negative length values are taken as measured in the reverse
direction from the end of the geometry. Out-of-range index
values are handled by clamping them to the valid range of values.
If the normalized arg is True, the distance will be interpreted as a
fraction of the geometry’s length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.intersection" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intersection of the geometries</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.intersects">
<span class="sig-name descname"><span class="pre">intersects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.intersects" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries intersect, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.normalize" title="Permalink to this definition"></a></dt>
<dd><p>Converts geometry to normal form (or canonical form).</p>
<p>This method orders the coordinates, rings of a polygon and parts of
multi geometries consistently. Typically useful for testing purposes
(for example in combination with <cite>equals_exact</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.wkt</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="s2">&quot;MULTILINESTRING((0 0, 1 1), (3 3, 2 2))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">wkt</span>
<span class="go">&#39;MULTILINESTRING ((2 2, 3 3), (0 0, 1 1))&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.overlaps">
<span class="sig-name descname"><span class="pre">overlaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.overlaps" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries overlap, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.project" title="Permalink to this definition"></a></dt>
<dd><p>Returns the distance along this geometry to a point nearest the
specified point</p>
<p>If the normalized arg is True, return the distance normalized to the
length of the linear geometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.relate">
<span class="sig-name descname"><span class="pre">relate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.relate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the DE-9IM intersection matrix for the two geometries
(string)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.relate_pattern">
<span class="sig-name descname"><span class="pre">relate_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.relate_pattern" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the DE-9IM string code for the relationship between
the geometries satisfies the pattern, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.representative_point">
<span class="sig-name descname"><span class="pre">representative_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.representative_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a point guaranteed to be within the object, cheaply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_topology</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.simplify" title="Permalink to this definition"></a></dt>
<dd><p>Returns a simplified geometry produced by the Douglas-Peucker
algorithm</p>
<p>Coordinates of the simplified geometry will be no more than the
tolerance distance from the original. Unless the topology preserving
option is used, the algorithm may produce self-intersecting or
otherwise invalid geometries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.svg">
<span class="sig-name descname"><span class="pre">svg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/point/#Point.svg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Point.svg" title="Permalink to this definition"></a></dt>
<dd><p>Returns SVG circle element for the Point geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale_factor</strong> (<em>float</em>) – Multiplication factor for the SVG circle diameter.  Default is 1.</p></li>
<li><p><strong>fill_color</strong> (<em>str</em><em>, </em><em>optional</em>) – Hex string for fill color. Default is to use “#66cc99” if
geometry is valid, and “#ff3333” if invalid.</p></li>
<li><p><strong>opacity</strong> (<em>float</em>) – Float number between 0 and 1 for color opacity. Default value is 0.6</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.symmetric_difference">
<span class="sig-name descname"><span class="pre">symmetric_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.symmetric_difference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the symmetric difference of the geometries
(Shapely geometry)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.touches">
<span class="sig-name descname"><span class="pre">touches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.touches" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries touch, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.union">
<span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.union" title="Permalink to this definition"></a></dt>
<dd><p>Returns the union of the geometries (Shapely geometry)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Point.within">
<span class="sig-name descname"><span class="pre">within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Point.within" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometry is within the other, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.area">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">area</span></span><a class="headerlink" href="#lasso.util.Point.area" title="Permalink to this definition"></a></dt>
<dd><p>Unitless area of the geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.array_interface_base">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">array_interface_base</span></span><a class="headerlink" href="#lasso.util.Point.array_interface_base" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#lasso.util.Point.boundary" title="Permalink to this definition"></a></dt>
<dd><p>Returns a lower dimension geometry that bounds the object</p>
<p>The boundary of a polygon is a line, the boundary of a line is a
collection of points. The boundary of a point is an empty (null)
collection.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.bounds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bounds</span></span><a class="headerlink" href="#lasso.util.Point.bounds" title="Permalink to this definition"></a></dt>
<dd><p>Returns minimum bounding region (minx, miny, maxx, maxy)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.centroid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centroid</span></span><a class="headerlink" href="#lasso.util.Point.centroid" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geometric center of the object</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.convex_hull">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convex_hull</span></span><a class="headerlink" href="#lasso.util.Point.convex_hull" title="Permalink to this definition"></a></dt>
<dd><p>that’s a
convex hull, more or less</p>
<p>The convex hull of a three member multipoint, for example, is a
triangular polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Imagine an elastic band stretched around the geometry</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.coords">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coords</span></span><a class="headerlink" href="#lasso.util.Point.coords" title="Permalink to this definition"></a></dt>
<dd><p>Access to geometry’s coordinates (CoordinateSequence)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.ctypes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ctypes</span></span><a class="headerlink" href="#lasso.util.Point.ctypes" title="Permalink to this definition"></a></dt>
<dd><p>Return ctypes buffer</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.envelope">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">envelope</span></span><a class="headerlink" href="#lasso.util.Point.envelope" title="Permalink to this definition"></a></dt>
<dd><p>A figure that envelopes the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.geom_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geom_type</span></span><a class="headerlink" href="#lasso.util.Point.geom_type" title="Permalink to this definition"></a></dt>
<dd><p>Name of the geometry’s type, such as ‘Point’</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.has_z">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_z</span></span><a class="headerlink" href="#lasso.util.Point.has_z" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry’s coordinate sequence(s) have z values (are
3-dimensional)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.Point.impl">
<span class="sig-name descname"><span class="pre">impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;GEOSImpl</span> <span class="pre">object:</span> <span class="pre">GEOS</span> <span class="pre">C</span> <span class="pre">API</span> <span class="pre">version</span> <span class="pre">(1,</span> <span class="pre">13,</span> <span class="pre">0)&gt;</span></em><a class="headerlink" href="#lasso.util.Point.impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.is_closed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_closed</span></span><a class="headerlink" href="#lasso.util.Point.is_closed" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is closed, else False</p>
<p>Applicable only to 1-D geometries.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.is_empty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_empty</span></span><a class="headerlink" href="#lasso.util.Point.is_empty" title="Permalink to this definition"></a></dt>
<dd><p>True if the set of points in this geometry is empty, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.is_ring">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_ring</span></span><a class="headerlink" href="#lasso.util.Point.is_ring" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is a closed ring, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.is_simple">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_simple</span></span><a class="headerlink" href="#lasso.util.Point.is_simple" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is simple, meaning that any self-intersections
are only at boundary points, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.is_valid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_valid</span></span><a class="headerlink" href="#lasso.util.Point.is_valid" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is valid (definition depends on sub-class),
else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.length">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#lasso.util.Point.length" title="Permalink to this definition"></a></dt>
<dd><p>Unitless length of the geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.minimum_clearance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimum_clearance</span></span><a class="headerlink" href="#lasso.util.Point.minimum_clearance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless distance by which a node could be moved to produce an invalid geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.minimum_rotated_rectangle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimum_rotated_rectangle</span></span><a class="headerlink" href="#lasso.util.Point.minimum_rotated_rectangle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the general minimum bounding rectangle of
the geometry. Can possibly be rotated. If the convex hull
of the object is a degenerate (line or point) this same degenerate
is returned.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#lasso.util.Point.type" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.wkb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkb</span></span><a class="headerlink" href="#lasso.util.Point.wkb" title="Permalink to this definition"></a></dt>
<dd><p>WKB representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.wkb_hex">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkb_hex</span></span><a class="headerlink" href="#lasso.util.Point.wkb_hex" title="Permalink to this definition"></a></dt>
<dd><p>WKB hex representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.wkt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkt</span></span><a class="headerlink" href="#lasso.util.Point.wkt" title="Permalink to this definition"></a></dt>
<dd><p>WKT representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.x">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#lasso.util.Point.x" title="Permalink to this definition"></a></dt>
<dd><p>Return x coordinate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.xy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">xy</span></span><a class="headerlink" href="#lasso.util.Point.xy" title="Permalink to this definition"></a></dt>
<dd><p>Separate arrays of X and Y coordinate values</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">[0.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.y">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#lasso.util.Point.y" title="Permalink to this definition"></a></dt>
<dd><p>Return y coordinate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Point.z">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">z</span></span><a class="headerlink" href="#lasso.util.Point.z" title="Permalink to this definition"></a></dt>
<dd><p>Return z coordinate.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lasso.util.Polygon">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">Polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/polygon/#Polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Polygon" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseGeometry</span></code></p>
<p>A two-dimensional figure bounded by a linear ring</p>
<p>A polygon has a non-zero area. It may have one or more negative-space
“holes” which are also bounded by linear rings. If any rings cross each
other, the feature is invalid and operations on it may fail.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.Polygon.exterior">
<span class="sig-name descname"><span class="pre">exterior</span></span><a class="headerlink" href="#lasso.util.Polygon.exterior" title="Permalink to this definition"></a></dt>
<dd><p>The ring which bounds the positive space of the polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>LinearRing</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.Polygon.interiors">
<span class="sig-name descname"><span class="pre">interiors</span></span><a class="headerlink" href="#lasso.util.Polygon.interiors" title="Permalink to this definition"></a></dt>
<dd><p>A sequence of rings which bound all existing holes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>sequence</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.almost_equals">
<span class="sig-name descname"><span class="pre">almost_equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.almost_equals" title="Permalink to this definition"></a></dt>
<dd><p>True if geometries are equal at all coordinates to a
specified decimal place.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.8.0: </span>The ‘almost_equals()’ method is deprecated
and will be removed in Shapely 2.0 because the name is
confusing. The ‘equals_exact()’ method should be used
instead.</p>
</div>
<p>Refers to approximate coordinate equality, which requires
coordinates to be approximately equal and in the same order for
all components of a geometry.</p>
<p>Because of this it is possible for “equals()” to be True for two
geometries and “almost_equals()” to be False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]),</span>
<span class="gp">... </span>    <span class="mf">1e-6</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.buffer">
<span class="sig-name descname"><span class="pre">buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadsegs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cap_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">join_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mitre_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single_sided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.buffer" title="Permalink to this definition"></a></dt>
<dd><p>Get a geometry that represents all points within a distance
of this geometry.</p>
<p>A positive distance produces a dilation, a negative distance an
erosion. A very small or zero distance may sometimes be used to
“tidy” a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> (<em>float</em>) – The distance to buffer around the object.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The resolution of the buffer around each vertex of the
object.</p></li>
<li><p><strong>quadsegs</strong> (<em>int</em><em>, </em><em>optional</em>) – Sets the number of line segments used to approximate an
angle fillet.  Note: the use of a <cite>quadsegs</cite> parameter is
deprecated and will be gone from the next major release.</p></li>
<li><p><strong>cap_style</strong> (<em>int</em><em>, </em><em>optional</em>) – The styles of caps are: CAP_STYLE.round (1), CAP_STYLE.flat
(2), and CAP_STYLE.square (3).</p></li>
<li><p><strong>join_style</strong> (<em>int</em><em>, </em><em>optional</em>) – The styles of joins between offset segments are:
JOIN_STYLE.round (1), JOIN_STYLE.mitre (2), and
JOIN_STYLE.bevel (3).</p></li>
<li><p><strong>mitre_limit</strong> (<em>float</em><em>, </em><em>optional</em>) – The mitre limit ratio is used for very sharp corners. The
mitre ratio is the ratio of the distance from the corner to
the end of the mitred offset corner. When two line segments
meet at a sharp angle, a miter join will extend the original
geometry. To prevent unreasonable geometry, the mitre limit
allows controlling the maximum length of the join corner.
Corners with a ratio which exceed the limit will be beveled.</p></li>
<li><p><strong>single_side</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>The side used is determined by the sign of the buffer
distance:</p>
<blockquote>
<div><p>a positive distance indicates the left-hand side
a negative distance indicates the right-hand side</p>
</div></blockquote>
<p>The single-sided buffer of point geometries is the same as
the regular buffer.  The End Cap Style for single-sided
buffers is always ignored, and forced to the equivalent of
CAP_FLAT.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Geometry</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The return value is a strictly two-dimensional geometry. All
Z coordinates of the original geometry will be ignored.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.wkt</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="s1">&#39;POINT (0.0 0.0)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>        <span class="c1"># 16-gon approx of a unit radius circle</span>
<span class="go">3.1365484905459...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>   <span class="c1"># 128-gon approximation</span>
<span class="go">3.141513801144...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># triangle approximation</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="n">CAP_STYLE</span><span class="o">.</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
<span class="go">[(1.0, 1.0), (1.0, -1.0), (-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="n">CAP_STYLE</span><span class="o">.</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.contains" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry contains the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.covered_by">
<span class="sig-name descname"><span class="pre">covered_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.covered_by" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry is covered by the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.covers">
<span class="sig-name descname"><span class="pre">covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.covers" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometry covers the other, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.crosses">
<span class="sig-name descname"><span class="pre">crosses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.crosses" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the geometries cross, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.difference">
<span class="sig-name descname"><span class="pre">difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.difference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the difference of the geometries</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.disjoint">
<span class="sig-name descname"><span class="pre">disjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.disjoint" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries are disjoint, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.distance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless distance to other geometry (float)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">93892948296208</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.empty" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.equals">
<span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.equals" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries are equal, else False.</p>
<p>This method considers point-set equality (or topological
equality), and is equivalent to (self.within(other) &amp;
self.contains(other)).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.equals_exact">
<span class="sig-name descname"><span class="pre">equals_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.equals_exact" title="Permalink to this definition"></a></dt>
<dd><p>True if geometries are equal to within a specified
tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>BaseGeometry</em>) – The other geometry object in this comparison.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Absolute tolerance in the same units as coordinates.</p></li>
<li><p><strong>equality</strong> (<em>This method considers coordinate</em>) – </p></li>
<li><p><strong>requires</strong> (<em>which</em>) – </p></li>
<li><p><strong>components</strong> (<em>coordinates to be equal and in the same order for all</em>) – </p></li>
<li><p><strong>geometry.</strong> (<em>of a</em>) – </p></li>
<li><p><strong>two</strong> (<em>Because</em><em> of </em><em>this it is possible for &quot;equals</em><em>(</em><em>)</em><em>&quot; to be True for</em>) – </p></li>
<li><p><strong>False.</strong> (<em>geometries and &quot;equals_exact</em><em>(</em><em>)</em><em>&quot; to be</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LineString</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]),</span>
<span class="gp">... </span>    <span class="mf">1e-6</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.from_bounds">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/polygon/#Polygon.from_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Polygon.from_bounds" title="Permalink to this definition"></a></dt>
<dd><p>Construct a <cite>Polygon()</cite> from spatial bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.geometryType">
<span class="sig-name descname"><span class="pre">geometryType</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.geometryType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.hausdorff_distance">
<span class="sig-name descname"><span class="pre">hausdorff_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.hausdorff_distance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless hausdorff distance to other geometry (float)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.interpolate" title="Permalink to this definition"></a></dt>
<dd><p>Return a point at the specified distance along a linear geometry</p>
<p>Negative length values are taken as measured in the reverse
direction from the end of the geometry. Out-of-range index
values are handled by clamping them to the valid range of values.
If the normalized arg is True, the distance will be interpreted as a
fraction of the geometry’s length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.intersection" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intersection of the geometries</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.intersects">
<span class="sig-name descname"><span class="pre">intersects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.intersects" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries intersect, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.normalize" title="Permalink to this definition"></a></dt>
<dd><p>Converts geometry to normal form (or canonical form).</p>
<p>This method orders the coordinates, rings of a polygon and parts of
multi geometries consistently. Typically useful for testing purposes
(for example in combination with <cite>equals_exact</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.wkt</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="s2">&quot;MULTILINESTRING((0 0, 1 1), (3 3, 2 2))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">wkt</span>
<span class="go">&#39;MULTILINESTRING ((2 2, 3 3), (0 0, 1 1))&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.overlaps">
<span class="sig-name descname"><span class="pre">overlaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.overlaps" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries overlap, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.project" title="Permalink to this definition"></a></dt>
<dd><p>Returns the distance along this geometry to a point nearest the
specified point</p>
<p>If the normalized arg is True, return the distance normalized to the
length of the linear geometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.relate">
<span class="sig-name descname"><span class="pre">relate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.relate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the DE-9IM intersection matrix for the two geometries
(string)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.relate_pattern">
<span class="sig-name descname"><span class="pre">relate_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.relate_pattern" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the DE-9IM string code for the relationship between
the geometries satisfies the pattern, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.representative_point">
<span class="sig-name descname"><span class="pre">representative_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.representative_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a point guaranteed to be within the object, cheaply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_topology</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.simplify" title="Permalink to this definition"></a></dt>
<dd><p>Returns a simplified geometry produced by the Douglas-Peucker
algorithm</p>
<p>Coordinates of the simplified geometry will be no more than the
tolerance distance from the original. Unless the topology preserving
option is used, the algorithm may produce self-intersecting or
otherwise invalid geometries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.svg">
<span class="sig-name descname"><span class="pre">svg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/geometry/polygon/#Polygon.svg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.Polygon.svg" title="Permalink to this definition"></a></dt>
<dd><p>Returns SVG path element for the Polygon geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale_factor</strong> (<em>float</em>) – Multiplication factor for the SVG stroke-width.  Default is 1.</p></li>
<li><p><strong>fill_color</strong> (<em>str</em><em>, </em><em>optional</em>) – Hex string for fill color. Default is to use “#66cc99” if
geometry is valid, and “#ff3333” if invalid.</p></li>
<li><p><strong>opacity</strong> (<em>float</em>) – Float number between 0 and 1 for color opacity. Default value is 0.6</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.symmetric_difference">
<span class="sig-name descname"><span class="pre">symmetric_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.symmetric_difference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the symmetric difference of the geometries
(Shapely geometry)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.touches">
<span class="sig-name descname"><span class="pre">touches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.touches" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometries touch, else False</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.union">
<span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.union" title="Permalink to this definition"></a></dt>
<dd><p>Returns the union of the geometries (Shapely geometry)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lasso.util.Polygon.within">
<span class="sig-name descname"><span class="pre">within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.Polygon.within" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if geometry is within the other, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.area">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">area</span></span><a class="headerlink" href="#lasso.util.Polygon.area" title="Permalink to this definition"></a></dt>
<dd><p>Unitless area of the geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.array_interface_base">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">array_interface_base</span></span><a class="headerlink" href="#lasso.util.Polygon.array_interface_base" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#lasso.util.Polygon.boundary" title="Permalink to this definition"></a></dt>
<dd><p>Returns a lower dimension geometry that bounds the object</p>
<p>The boundary of a polygon is a line, the boundary of a line is a
collection of points. The boundary of a point is an empty (null)
collection.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.bounds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bounds</span></span><a class="headerlink" href="#lasso.util.Polygon.bounds" title="Permalink to this definition"></a></dt>
<dd><p>Returns minimum bounding region (minx, miny, maxx, maxy)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.centroid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centroid</span></span><a class="headerlink" href="#lasso.util.Polygon.centroid" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geometric center of the object</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.convex_hull">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convex_hull</span></span><a class="headerlink" href="#lasso.util.Polygon.convex_hull" title="Permalink to this definition"></a></dt>
<dd><p>that’s a
convex hull, more or less</p>
<p>The convex hull of a three member multipoint, for example, is a
triangular polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Imagine an elastic band stretched around the geometry</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.coords">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coords</span></span><a class="headerlink" href="#lasso.util.Polygon.coords" title="Permalink to this definition"></a></dt>
<dd><p>Access to geometry’s coordinates (CoordinateSequence)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.ctypes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ctypes</span></span><a class="headerlink" href="#lasso.util.Polygon.ctypes" title="Permalink to this definition"></a></dt>
<dd><p>Return ctypes buffer</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.envelope">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">envelope</span></span><a class="headerlink" href="#lasso.util.Polygon.envelope" title="Permalink to this definition"></a></dt>
<dd><p>A figure that envelopes the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exterior</span></span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.geom_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geom_type</span></span><a class="headerlink" href="#lasso.util.Polygon.geom_type" title="Permalink to this definition"></a></dt>
<dd><p>Name of the geometry’s type, such as ‘Point’</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.has_z">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_z</span></span><a class="headerlink" href="#lasso.util.Polygon.has_z" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry’s coordinate sequence(s) have z values (are
3-dimensional)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.Polygon.impl">
<span class="sig-name descname"><span class="pre">impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;GEOSImpl</span> <span class="pre">object:</span> <span class="pre">GEOS</span> <span class="pre">C</span> <span class="pre">API</span> <span class="pre">version</span> <span class="pre">(1,</span> <span class="pre">13,</span> <span class="pre">0)&gt;</span></em><a class="headerlink" href="#lasso.util.Polygon.impl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id1">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">interiors</span></span><a class="headerlink" href="#id1" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.is_closed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_closed</span></span><a class="headerlink" href="#lasso.util.Polygon.is_closed" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is closed, else False</p>
<p>Applicable only to 1-D geometries.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.is_empty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_empty</span></span><a class="headerlink" href="#lasso.util.Polygon.is_empty" title="Permalink to this definition"></a></dt>
<dd><p>True if the set of points in this geometry is empty, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.is_ring">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_ring</span></span><a class="headerlink" href="#lasso.util.Polygon.is_ring" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is a closed ring, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.is_simple">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_simple</span></span><a class="headerlink" href="#lasso.util.Polygon.is_simple" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is simple, meaning that any self-intersections
are only at boundary points, else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.is_valid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_valid</span></span><a class="headerlink" href="#lasso.util.Polygon.is_valid" title="Permalink to this definition"></a></dt>
<dd><p>True if the geometry is valid (definition depends on sub-class),
else False</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.length">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#lasso.util.Polygon.length" title="Permalink to this definition"></a></dt>
<dd><p>Unitless length of the geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.minimum_clearance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimum_clearance</span></span><a class="headerlink" href="#lasso.util.Polygon.minimum_clearance" title="Permalink to this definition"></a></dt>
<dd><p>Unitless distance by which a node could be moved to produce an invalid geometry (float)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.minimum_rotated_rectangle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimum_rotated_rectangle</span></span><a class="headerlink" href="#lasso.util.Polygon.minimum_rotated_rectangle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the general minimum bounding rectangle of
the geometry. Can possibly be rotated. If the convex hull
of the object is a degenerate (line or point) this same degenerate
is returned.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#lasso.util.Polygon.type" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.wkb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkb</span></span><a class="headerlink" href="#lasso.util.Polygon.wkb" title="Permalink to this definition"></a></dt>
<dd><p>WKB representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.wkb_hex">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkb_hex</span></span><a class="headerlink" href="#lasso.util.Polygon.wkb_hex" title="Permalink to this definition"></a></dt>
<dd><p>WKB hex representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.wkt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wkt</span></span><a class="headerlink" href="#lasso.util.Polygon.wkt" title="Permalink to this definition"></a></dt>
<dd><p>WKT representation of the geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lasso.util.Polygon.xy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">xy</span></span><a class="headerlink" href="#lasso.util.Polygon.xy" title="Permalink to this definition"></a></dt>
<dd><p>Separate arrays of X and Y coordinate values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lasso.util.partial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">partial</span></span><a class="reference internal" href="../../_modules/functools/#partial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.partial" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>partial(func, <a href="#id2"><span class="problematic" id="id3">*</span></a>args, <a href="#id4"><span class="problematic" id="id5">**</span></a>keywords) - new function with partial application
of the given arguments and keywords.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.partial.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#lasso.util.partial.args" title="Permalink to this definition"></a></dt>
<dd><p>tuple of arguments to future partial calls</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.partial.func">
<span class="sig-name descname"><span class="pre">func</span></span><a class="headerlink" href="#lasso.util.partial.func" title="Permalink to this definition"></a></dt>
<dd><p>function object to use in future partial calls</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lasso.util.partial.keywords">
<span class="sig-name descname"><span class="pre">keywords</span></span><a class="headerlink" href="#lasso.util.partial.keywords" title="Permalink to this definition"></a></dt>
<dd><p>dictionary of keyword arguments to future partial calls</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.column_name_to_parts">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">column_name_to_parts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#column_name_to_parts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.column_name_to_parts" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.create_locationreference">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">create_locationreference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#create_locationreference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.create_locationreference" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.geodesic_point_buffer">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">geodesic_point_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#geodesic_point_buffer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.geodesic_point_buffer" title="Permalink to this definition"></a></dt>
<dd><p>creates circular buffer polygon for node</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> – node lat</p></li>
<li><p><strong>lon</strong> – node lon</p></li>
<li><p><strong>meters</strong> – buffer distance, radius of circle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Polygon</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.get_shared_streets_intersection_hash">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">get_shared_streets_intersection_hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">osm_node_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#get_shared_streets_intersection_hash"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.get_shared_streets_intersection_hash" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Calculated per:</dt><dd><p><a class="reference external" href="https://github.com/sharedstreets/sharedstreets-js/blob/0e6d7de0aee2e9ae3b007d1e45284b06cc241d02/src/index.ts#L553-L565">https://github.com/sharedstreets/sharedstreets-js/blob/0e6d7de0aee2e9ae3b007d1e45284b06cc241d02/src/index.ts#L553-L565</a></p>
</dd>
<dt>Expected in/out</dt><dd><dl class="simple">
<dt>-93.0965985, 44.952112199999995 osm_node_id = 954734870</dt><dd><p>69f13f881649cb21ee3b359730790bb9</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.hhmmss_to_datetime">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">hhmmss_to_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hhmmss_str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#hhmmss_to_datetime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.hhmmss_to_datetime" title="Permalink to this definition"></a></dt>
<dd><p>Creates a datetime time object from a string of hh:mm:ss</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hhmmss_str</strong> – string of hh:mm:ss</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>datetime.time object representing time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dt</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.secs_to_datetime">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">secs_to_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">secs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#secs_to_datetime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.secs_to_datetime" title="Permalink to this definition"></a></dt>
<dd><p>Creates a datetime time object from a seconds from midnight</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>secs</strong> – seconds from midnight</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>datetime.time object representing time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dt</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.shorten_name">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">shorten_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lasso/util/#shorten_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.shorten_name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.transform">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geom</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/shapely/ops/#transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lasso.util.transform" title="Permalink to this definition"></a></dt>
<dd><p>Applies <cite>func</cite> to all coordinates of <cite>geom</cite> and returns a new
geometry of the same type from the transformed coordinates.</p>
<p><cite>func</cite> maps x, y, and optionally z to output xp, yp, zp. The input
parameters may iterable types like lists or arrays or single values.
The output shall be of the same type. Scalars in, scalars out.
Lists in, lists out.</p>
<p>For example, here is an identity function applicable to both types
of input.</p>
<blockquote>
<div><dl class="simple">
<dt>def id_func(x, y, z=None):</dt><dd><p>return tuple(filter(None, [x, y, z]))</p>
</dd>
</dl>
<p>g2 = transform(id_func, g1)</p>
</div></blockquote>
<p>Using pyproj &gt;= 2.1, this example will accurately project Shapely geometries:</p>
<blockquote>
<div><p>import pyproj</p>
<p>wgs84 = pyproj.CRS(‘EPSG:4326’)
utm = pyproj.CRS(‘EPSG:32618’)</p>
<p>project = pyproj.Transformer.from_crs(wgs84, utm, always_xy=True).transform</p>
<p>g2 = transform(project, g1)</p>
</div></blockquote>
<p>Note that the always_xy kwarg is required here as Shapely geometries only support
X,Y coordinate ordering.</p>
<p>Lambda expressions such as the one in</p>
<blockquote>
<div><p>g2 = transform(lambda x, y, z=None: (x+1.0, y+1.0), g1)</p>
</div></blockquote>
<p>also satisfy the requirements for <cite>func</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lasso.util.unidecode">
<span class="sig-prename descclassname"><span class="pre">lasso.util.</span></span><span class="sig-name descname"><span class="pre">unidecode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'?'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lasso.util.unidecode" title="Permalink to this definition"></a></dt>
<dd><p>Transliterate an Unicode object into an ASCII string</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unidecode</span><span class="p">(</span><span class="s2">&quot;北亰&quot;</span><span class="p">)</span>
<span class="go">&quot;Bei Jing &quot;</span>
</pre></div>
</div>
<p>This function first tries to convert the string using ASCII codec.
If it fails (because of non-ASCII characters), it falls back to
transliteration using the character tables.</p>
<p>This is approx. five times faster if the string only contains ASCII
characters, but slightly slower than unicode_expect_nonascii if
non-ASCII characters are present.</p>
<p>errors specifies what to do with characters that have not been
found in replacement tables. The default is ‘ignore’ which ignores
the character. ‘strict’ raises an UnidecodeError. ‘replace’
substitutes the character with replace_str (default is ‘?’).
‘preserve’ keeps the original character.</p>
<p>Note that if ‘preserve’ is used the returned string might not be
ASCII!</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../lasso.Parameters/" class="btn btn-neutral float-left" title="lasso.Parameters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../lasso.logger/" class="btn btn-neutral float-right" title="lasso.logger" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Metropolitan Council, Metropolitan Transportation Commission.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>